# pl/dotnet: Frequently Asked Questions

**Table of Contents**

- [pl/dotnet: Frequently Asked Questions](#pldotnet-frequently-asked-questions)
  - [Q: What is pl/dotnet?](#q-what-is-pldotnet)
  - [Q: Which version of pl/dotnet does this FAQ cover?](#q-which-version-of-pldotnet-does-this-faq-cover)
  - [Q: What languages are supported?](#q-what-languages-are-supported)
  - [Q: Can I see an example?](#q-can-i-see-an-example)
  - [Q: How do I use pl/dotnet?](#q-how-do-i-use-pldotnet)
  - [Q: Is pl/dotnet fast?](#q-is-pldotnet-fast)
  - [Q: Does pl/dotnet support a lot of types?](#q-does-pldotnet-support-a-lot-of-types)
  - [Q: How does pl/dotnet make use of Npgsql?](#q-how-does-pldotnet-make-use-of-npgsql)
  - [Q: How compatible is my Npgsql client code with pl/dotnet?](#q-how-compatible-is-my-npgsql-client-code-with-pldotnet)
  - [Q: How complete is your F# support compared to C#?](#q-how-complete-is-your-f-support-compared-to-c)
  - [Q: How good is the code quality is pl/dotnet?](#q-how-good-is-the-code-quality-is-pldotnet)
  - [Q: Is the code well commented?](#q-is-the-code-well-commented)
  - [Q: Does pl/dotnet support INOUT or OUT parameters?](#q-does-pldotnet-support-inout-or-out-parameters)
  - [Q: How do I see the C#/F# code generated by pl/dotnet?](#q-how-do-i-see-the-cf-code-generated-by-pldotnet)
  - [Q: How do I install pl/dotnet?](#q-how-do-i-install-pldotnet)
  - [Q: What versions of .NET are supported?](#q-what-versions-of-net-are-supported)
  - [Q: What versions of PostgreSQL are supported?](#q-what-versions-of-postgresql-are-supported)
  - [Q: Where can I get the source code for pl/dotnet?](#q-where-can-i-get-the-source-code-for-pldotnet)
  - [Q: Where can I read the documentation for pl/dotnet?](#q-where-can-i-read-the-documentation-for-pldotnet)
  - [Q: Is there a white paper explaining the project?](#q-is-there-a-white-paper-explaining-the-project)
  - [Q: Are triggers supported?](#q-are-triggers-supported)
  - [Q: Is SPI supported?](#q-is-spi-supported)
  - [Q: Are set-returning functions (SRFs) supported?](#q-are-set-returning-functions-srfs-supported)
  - [Q: What data types are supported?](#q-what-data-types-are-supported)
  - [Q: How are NULLs handled?](#q-how-are-nulls-handled)
  - [Q: Why does the type mapping change depending on whether my function is `STRICT`?](#q-why-does-the-type-mapping-change-depending-on-whether-my-function-is-strict)
  - [Q: How are arrays handled?](#q-how-are-arrays-handled)
  - [Q: What is the performance problem with arrays?](#q-what-is-the-performance-problem-with-arrays)
  - [Q: Can I load my code from a DLL?](#q-can-i-load-my-code-from-a-dll)
  - [Q: How safe is pl/dotnet?](#q-how-safe-is-pldotnet)
  - [Q: How isolated are functions in pl/dotnet?](#q-how-isolated-are-functions-in-pldotnet)
  - [Q: Who is responsible for pl/dotnet?](#q-who-is-responsible-for-pldotnet)
  - [Q: How do I write efficient and secure C# stored procedures in pl/dotnet?](#q-how-do-i-write-efficient-and-secure-c-stored-procedures-in-pldotnet)
  - [Q: Can I use any C#/F# library in pl/dotnet?](#q-can-i-use-any-cf-library-in-pldotnet)

## Q: What is pl/dotnet?

The pl/dotnet project extends PostgreSQL to support functions, stored procedures and `DO` blocks for the dotnet platform, including both C# and F#.

## Q: Which version of pl/dotnet does this FAQ cover?

This FAQ is for the version 1.0 release of pl/dotnet, released in January 2023.

## Q: What languages are supported?

pl/dotnet supports the creation of stored procedures, functions, and `DO` blocks in both C# and F#, which can be used inside of PostgreSQL as the `plcsharp` and `plfsharp` languages, respectively.

## Q: Can I see an example?

Of course.  Here is a basic example:

```sql
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER) RETURNS INTEGER AS $$
return a+1;
$$ LANGUAGE plcsharp STRICT;
```

## Q: How do I use pl/dotnet?

After you install it, you can use the normal Postgresql `CREATE FUNCTION` or `CREATE PROCEDURE` syntax. The language is `plcsharp` or `plfsharp` depending on your choice of C# or F#.

## Q: Is pl/dotnet fast?

In our benchmarks, pl/csharp is the fastest external procedural language in PostgreSQL.  We are nearly as fast as pl/pgsql.  (The performance of pl/fsharp is practically identical to pl/csharp, with a few exceptions.)

These benchmarks are somewhat arbitrary, merely having been designed for our own needs, but the were not cherry picked or tuned; we built the tests first and only benchmarked them afterwards. It is possible that some of our implementation choices in other languages were sub-optimal, and we welcome corrections, but the consistency of the results across multiple languages makes us reasonably confident in the data. The tests are available in our repository for inspection, and we hope to share them in more polished form for use by other PL teams.

Our benchmark results were aided by .NET's excellent handling of recursive functions; we generally beat other languages by a considerable margin on these benchmarks.  Our benchmark results were harmed by our handling of arrays, which is currently compatible with Npgsql's convention and is therefore unnecessarily slow. (We intend to improve this soon, though these improvements will be optional since they are not Npgsql-compatible.)

## Q: Does pl/dotnet support a lot of types?

We were able to achieve native representation for 38 types, plus their arrays, the widest range of types of any external procedural language in PostgreSQL.

The full list can be found in our white paper or in the technical documentation.

## Q: How does pl/dotnet make use of Npgsql?

Npgsql is an open source ADO.NET Data Provider for PostgreSQL. You can find out more at their website, [https://www.npgsql.org/](https://www.npgsql.org/).

pl/dotnet uses Npgsql to map PostgreSQL data types to .NET data types. This provides us a very high quality of data type mapping, since Npgsql has long been in widespread use, and it maximizes code mobility for developers seeking to move their client code into the database as stored procedures.

pl/dotnet also uses Npgsql in our implementation of SPI, which is currently under development.

We believe that maximal compatibility with Npgsql will allow transparent migration of C# and F# code from the client to the server, which is a strategic goal for our project.

## Q: How compatible is my Npgsql client code with pl/dotnet?

At the moment, we are 100% compatible with all supported Npgsql types. There are several deviations from the Npgsql type mapping which we are contemplating in the future, but we believe that Npgsql compatibility will remain our default, with developers being able to opt into the alternative APIs at their discretion.

## Q: How complete is your F# support compared to C#?

Thanks to the magic of .NET, everything that works in C# *should* work in F#. We have complete unit testing for all data types in both C# and F#.

## Q: How good is the code quality is pl/dotnet?

- We have complete unit testing in C# and F# for all supported data types, their arrays, and nulls for that type.
- Cpplint is a static code checker for C and C++.  pl/dotnet is clean under its checks.
- StyleCop is a static code analysis tool for C#.  pl/dotnet is clean under its checks.
- SonarLint is a code quality and security static analysis tool with almost 5000 rules.  pl/dotnet is clean under its checks.

## Q: Is the code well commented?

All C and C# code is commented using Doxygen, and we encourage you to consult the generated Doxygen documentation.

## Q: Does pl/dotnet support INOUT or OUT parameters?

pl/dotnet currently supports only parameter input, not parameter output. Thus, we consume both `IN` and `INOUT` parameters, but it is not currently possible to output an `INOUT` parameter. We silently skip `OUT` parameters. This handling matches the current handling in pl/python.

.NET supports output parameters, and we anticipate fully supporting value output for both `INOUT` and `OUT` parameters.

## Q: How do I see the C#/F# code generated by pl/dotnet?

To save the generated codes to files, you need to set the `SaveSourceCode` variable in `dotnet_src/Engine.cs` to `true` and specify the location by updating the `PathToSaveSourceCode` variable in the same file. You need to make sure that this path has mode of `0700`. Alternatively, you can set the `PrintSourceCode` variable in `dotnet_src/Engine.cs` to `true` to print the generated code to the console.

Note that after making changes to the `dotnet_src/Engine.cs` file, you will need to rebuild the Debian packages and reinstall pl/dotnet.

## Q: How do I install pl/dotnet?

See our `INSTALL` file at the top level of our source code.

## Q: What versions of .NET are supported?

We currently support .NET version 6 and will soon add support for .NET version 7.

## Q: What versions of PostgreSQL are supported?

We currently support PostgreSQL versions 10, 11, 12, 13, 14, and 15.

## Q: Where can I get the source code for pl/dotnet?

The official repository for pl/dotnet is https://github.com/Brick-Abode/pldotnet/.

## Q: Where can I read the documentation for pl/dotnet?

Our project wiki is at https://github.com/Brick-Abode/pldotnet/wiki.

## Q: Is there a white paper explaining the project?

Yes, titled "The pl/dotnet Extension to PostgreSQL, v1". It is included in our source code in the `docs/` subdirectory.

FIXME: add download location from our website

## Q: Are triggers supported?

Triggers are not currently supported. We do have an initial implementation and hope to add full support soon.

## Q: Is SPI supported?

SPI is not currently supported.  We have a very basic implementation working internally and hope to add full support soon.

## Q: Are set-returning functions (SRFs) supported?

SRFs are not currently supported.  We have an initial implementation working internally and hope to add full support soon.

## Q: What data types are supported?

All the data types supported by pl/dotnet can be found in our [Wiki page](https://github.com/Brick-Abode/pldotnet/wiki/08.-Data-type-mapping).

## Q: How are NULLs handled?

Null is mapped to `null` in C# and F#.  By default, all types in pl/dotnet are nullable.  You will see that as `T?` in C# and `Option<T>` in F#.

## Q: Why does the type mapping change depending on whether my function is `STRICT`?

A normal PostgreSQL function can be passed NULL as an argument. In order to handle this, pl/dotnet maps such types to their optional C# or F# type. For example, a PostgreSQL `INT4` is mapped to a `int?` in C#; this allows NULL to be handled in the standard way in the user function.

Some developers find such handling tedious and do not wish to be passed NULL. Fortunately, PostgreSQL supports this; you can
declare your function to be `STRICT` (or `RETURNS NULL ON NULL INPUT`, which is an alias for `STRICT`.)

Functions declared in this way will give an error if called with NULL, so the user function will never see a NULL value. For this reason, the type mapping is changed; `INT4` arguments are now mapped to `int` in C#, saving the developer the trouble of handling null values.

## Q: How are arrays handled?

Because PostgreSQL does not enforce dimensioning on its arrays, Npgsql uses a very generic, boxed version of arrays in its API. You can read more about it here: https://www.npgsql.org/efcore/mapping/array.html.

pl/dotnet currently supports the Npgsql mapping.

## Q: What is the performance problem with arrays?

Because arrays are boxed, and because you don't know the dimensionality of an array, they are more like trees than arrays, and navigating them is tedious and slow.

We have ideas for how this can be improved in future versions, but for now we handle arrays exactly the same way that Npgsql does.

## Q: Can I load my code from a DLL?

Yes, you can. Here is an example:

```sql
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER) RETURNS INTEGER
AS 'Test.dll:Namespace.Class!IntegerTest'
LANGUAGE plcsharp STRICT;
```

To use your assembly with pl/dotnet, place it in the `/var/lib/postgresql/data/` directory. Alternatively, you can specify the full path to the assembly in the `CREATE OR REPLACE FUNCTION` statement, as demonstrated in this example:

```sql
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER) RETURNS INTEGER
AS '/path/to/Test.dll:Namespace.Class!IntegerTest'
LANGUAGE plcsharp STRICT;
```

## Q: How safe is pl/dotnet?

Currently, pl/dotnet outputs the source code for each function to `/tmp/PlDotNET/` for debugging.

Each function in pl/dotnet is placed in a separate AssemblyLoadContext in the .NET runtime (CLR).  This places significant barriers between sharing of data between functions.

.NET was not designed to provide perfect security guarantees for code running inside of it, nor were most of the other runtimes used in PostgreSQL procedural languages. We encourage stored procedure authors to be cautious of the security implications of running code in stored procedures.

## Q: How isolated are functions in pl/dotnet?

Each function in pl/dotnet is placed in a separate AssemblyLoadContext in the .NET runtime (CLR).

We hope to allow different functions loaded from the same DLL to share the same AssemblyLoadContext and look forward to implementing this soon.

## Q: Who is responsible for pl/dotnet?

pl/dotnet was built by the fine people at Brick Abode. We love ASP.NET development and PostgreSQL, and we build pl/dotnet to be the stored procedure environment that we wanted to have for working on our clients' projects. Feel free to talk to us about your ASP.NET development needs. Find out more at https://www.brickabode.com.

## Q: How do I write efficient and secure C# stored procedures in pl/dotnet?

- Use parameterized queries: Use parameterized queries to prevent SQL injection attacks.
- Use prepared statements: Use prepared statements to avoid parsing the same SQL statement multiple times.
- Use transactions: Use transactions to ensure that your stored procedures are atomic, consistent, isolated, and durable (ACID).
- Use the appropriate data types: Use the appropriate data types when passing data between C# and SQL Server to avoid unnecessary data conversions.
- Avoid using global variables: Global variables can be modified by any part of the code and can cause surprising behavior, so avoid using them where possible.
- Use proper error handling: Use proper error handling to catch errors and prevent your stored procedures from crashing.
- Use the `using` statement when working with database connections: The using statement will automatically handle the closing of the connection.
- Avoid using dynamic SQL if possible: Dynamic SQL can be vulnerable to SQL injection attacks and is harder to debug and maintain.
- Be mindful of memory usage: Be mindful of memory usage when working with large datasets and try to release memory as soon as it is no longer needed.
- Keep your stored procedures simple and focused: Avoid adding unnecessary complexity to your stored procedures, keep them simple, focused, and easy to understand.

It is also important to keep PostgreSQL updated with the latest security patches and use appropriate authentication and authorization methods for accessing your stored procedures.

## Q: Can I use any C#/F# library in pl/dotnet?

Users cannot currently load libraries into their pl/dotnet programs, but we hope to add this support soon. In the meantime, if you wish to use other libraries, you can create your own Assembly and load it as demonstrated in the question [Q: Can I load my code from a DLL?](#q-can-i-load-my-code-from-a-dll).
