\documentclass[sigconf,techreport,authorversion,nonacm]{acmart}

\usepackage{amsmath}
\usepackage{array}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{color}
\usepackage{colortbl}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{makecell}
\usepackage{multicol}
\usepackage[newfloat]{minted}
\usepackage{subcaption}
\usepackage{url}

\newcommand{\dotnet}{.NET}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}
\pagestyle{fancy}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\title}
\fancyhead[C]{\rule{\textwidth}{0.4pt}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}

\SetupFloatingEnvironment{listing}{name=Program code}

\title{The pl/dotnet extension to PostgreSQL, v0.9}

%%% Authors
\author{Todd Lewis}
\affiliation{%
       \institution{Brick Abode}
       \city{Florian√≥polis}
%       \state{Santa Catarina}
       \country{\textsc{Brazil}}
}
\email{tlewis@brickabode.com}

\begin{document}

\sloppy
% Show header
\thispagestyle{fancy}
\pagestyle{fancy}
% add page numbers
\settopmatter{printfolios=true}

\definecolor{pldotnet_gray}{RGB}{230,230,230}

% I cannot get this to work.
% \newcommand{\csharp_test_n}{ \num{397} }
% \newcommand{\fsharp_test_n}{ $ \num{423} $ }
% \newcommand{\csharp_test_n}{ $ \inteval{397} $ }
% \newcommand{\fsharp_test_n}{ $ \inteval{423} $ }
% \newcommand{\total_test_n}{ $ \csharp_test_n\ + \fsharp_test_n\ $ }

\begin{abstract}
pl/dotnet is a free software  project that extends PostgreSQL to
support stored procedures and functions for the \dotnet\ platform,
including both C\# and F\#.  In our tests it is the fastest procedural
language in PostgreSQL, and it has the widest range of unit testing.
It natively supports 38 out of 46 standard user types, the widest
range of any external procedural language in PostgreSQL.  We hope
to make it the best procedural language in PostgreSQL and the best
implementation of \dotnet\ stored procedures in any database;
important work remains.  We here present our work for consideration
and feedback.
\end{abstract}

\keywords{PostgreSQL, \dotnet\, pl/dotnet, C\#, F\#, stored procedures}

\maketitle

% TODO the text is using "We" but there is only 1 author

\section{Introduction}

% ### territory (what we have, the current state)

PostgreSQL is an extensible, open-sourced object-relational database management system~\cite{PostgreSQL2022}.
\dotnet\ (also \textquote{Dotnet})~\cite{DotNet2023} is an open-sourced, cross-platform development
framework including a JIT-compiler, a high-performance runtime, and
support (including cross-calling) for multiple languages, including
both C\# (an object-oriented dialect of C) and F\# (based on Ocaml,
an object-oriented dialect of ML.)

% # Current state

The PostgreSQL project includes support for user-defined functions, stored procedures, and triggers.
These can be implemented in a number of languages, including SQL, C, TCL, Perl, and Python in the standard distribution~\cite{PostgreSQL2022}, and Java~\cite{PLJava}, Lua~\cite{PLLua}, and R~\cite{PLR} outside of the standard definition.

% ### niche (motivation, the current gap)

%\footnote{pl/dotnet is unusual in PostgreSQL in that it is one extension which supports two languages; the PostgreSQL languages added are \textquote{plcsharp} and \textquote{plfsharp}.}
The pl/dotnet project extends PostgreSQL to support user functions,
procedures, and \texttt{DO} blocks.  for the \dotnet platform,
including both C\# and F\#.  We have achieved native representation
for 38 of out of 46 PostgreSQL user types, plus their arrays, the
widest range of any external procedural language in PostgreSQL. In
our benchmarks we are the fastest external procedural language in
PostgreSQL.
%\footnote{These benchmarks are somewhat arbitrary, merely having been designed for our own needs, but the were not cherry picked or tuned; we built the tests first and only benchmarked them afterwards. It is possible that some of our implementation choices in other languages were sub-optimal, and we welcome corrections, but the consistency of the results across multiple languages makes us reasonably confident in the data. The tests and test results are available in our repository for inspection.} Work remains, especially the complete implementation of the Server Programming Interface, but we think the initial results are promising, and we share them in this paper. pl/dotnet is a free software project, licensed under the PostgreSQL License.  Full source can be downloaded from our github repository\footnote{\url{https://github.com/Brick-Abode/pldotnet/}}.

%%%%% Motivation and Goals %%%%%

We were motivated to add \dotnet\ support to PostgreSQL for several
reasons:

First, \dotnet\ is a great platform for building servers. The \dotnet\
runtime is perhaps the best garbage-collected, multi-threaded runtime
in the world, with good scalability and the ability to run on all
modern operating systems. \dotnet\ has interesting native compilation
features. ASP.NET\footnote{\url{https://dotnet.microsoft.com/en-us/apps/aspnet}}
is a powerful framework for building web apps. Our company, Brick
Abode, has developed servers in this framework for many years and
is interested in the ability to run code easily and well as stored
procedures.

Second, \dotnet\ includes F\#, a strongly-typed functional programming
of the ML family. We are interested in the research potential of
using functional programming in a relational database environment,
so we have full support in pl/dotnet for F\#, making pl/dotnet (to
our knowledge) the only stored procedure implementation on a
relational database with full support for a functional programming
language with Hindley-Milner type inference.
%\footnote{The histories of both strongly-typed functional programming and relational databases are many decades long, with lengthy literatures, so we make this claim weakly and modestly; we are not aware of any precedent but welcome any such being brought to our attention.  We are industrial researchers, not an academics, and are therefore humble concerning our literature review abilities.}

Third, programmers have long used stored procedures in their architectures
for performance and security, but doing so is difficult because of
the environmental differences between traditional programming and
database programming: managing the software development life-cycle
is difficult, calling stored procedures can be tedious, and SQL-based
stored procedure languages such as Oracle's PL/SQL\footnote{\url{http://www.orafaq.com/wiki/PL/SQL_FAQ}}
, Sybase and Microsoft's T-SQL\footnote{\url{https://learn.microsoft.com/en-us/sql/t-sql/language-reference?view=sql-server-ver16}}
, and IBM's SQL PL\footnote{\url{https://www.ibm.com/docs/en/db2/11.1?topic=support-plsql-features}}
often require cross-team cooperation between developers and
database administrators on the software development, creating
project overhead.

We think these problems can be mostly or completely solved through
technical innovation.  Modern languages such as C\# give developers
tools which are in theory sufficient to eliminate this friction and
allow automated software deployment into the database environment,
creating a seamless developer experience.

Our project hopes to make this dream a reality, allowing developers
to easily move the code to the data instead of forcing the data to
come to the code. We think this would make the world a better place.

To make that happen, we want pl/dotnet to be the best stored procedure
languages for PostgreSQL and the best \dotnet\ stored procedure
language in any database.  We also want to improve the overall
ecosystem within PostgreSQL for stored procedure languages.

Specific goals include:
\begin{itemize}
    \item complete support for all standard PostgreSQL data types
    \item support for all aggregate types: ranges, arrays, sets, records
    \item rich support for C\# and F\#, including clear and detailed compiler error messages
    \item high performance
    \item memory safety
    \item compatibility with Npgsql, the existing \dotnet PostgreSQL client library
    \item limited compatibility with the C\# stored-procedure support in MS SQL Server and IBM DB/2
    \item full support, via the standard Npgsql API, for calling PostgreSQL from \dotnet functions via the Server Programming Interface (SPI)
    \item leveraging PostgreSQL's rich security model
    \item comprehensive testing
    \item good configurability
    \item an improved the PostgreSQL ecosystem for other procedural languages via shared testing and cooperation
\end{itemize}

% ### present approach and principal findings/results


%%%%%%%%% doc estructure

\section{pl/dotnet}

%%%% Summary of current state and future plans

% TODO:
% Explain what is pl/dot using diagram - Overview
% then, what is covering
% add link to repository

For context, we first present a feature summary, both currently
supported and planned for the future. All items in this list are
explained in more detail later in the paper.

\begin{itemize}[itemsep=0pt]
    \item Current support:
        \begin{itemize}
            \item Languages: C\# and F\# both fully supported
            \item Datatypes: 38 out of 46 PostgreSQL user (non-system) data types, plus their arrays
            \item All data types are nullable
            \item Code can be entered directly via \texttt{CREATE FUNCTION} or, alternatively, loaded from a pre-compiled assembly
            \item Performance is very good in our benchmarks, surpassing all other external PL implementations
            \item Testing: we have 820 unit tests; all types, plus their arrays and nulls, are fully unit-tested in both C\# and F\#
            \item Security: Code for each function is isolated in a \dotnet Assembly Load Context, providing some security protection
        \end{itemize}
    \item Future support:
        \begin{itemize}
            \item Datatypes: four types need to be added: multirange (of which there are five), enumerated, numeric, and composite
            \item SPI: basic SPI is privately working, but we want to make it 100\% Npgsql-compatible
            \item Triggers: we have triggers prototyped and will implement them fully
            \item Set-Returning Functions: will be mapped to \texttt{IEnumerable<T>} for both C\# and F\#
            \item Output parameter support
    \end{itemize}
\end{itemize}

\subsection{Data type support}

PostgreSQL has a rich type system, with 46 user types in the main
distribution. Any mapping of these types into a programming language
is going to face choices and numerous challenges about how to map
them, especially for intricate types such as datetimes.

Fortunately, there exists a widely-used mapping of PostgreSQL types
into \dotnet: the Npgsql\footnote{\url{https://www.npgsql.org/doc/types/basic.html}}
client library, with nearly 70,000 lines of code, handles these
conversions quite responsibly and is already in widespread use.

We embraced Npgsql compatibility as our goal and leveraged it to
map the types from PostgreSQL to \dotnet. This not only accelerated
our project, but it also ensured compatibility of \dotnet code
run as an external client or as an internal stored procedure.
This helps us with our strategic goal of making code mobility as
effortless for the programmer as possible.

While we expect our code size to increase as we add more features,
you can clearly see the advantage this approach gives us in Table
\ref{table:LOC}, which compares our code size to that of other
Procedural Language implementations in PostgreSQL\footnote{We here
count code in C/C++ as well as the native language, with the exception
of pl\/pgsql; we do not count their PL-specific SQL code, which is
unusually difficult to differentiate.  Lines of code were counted
using version 1.94 of the \texttt{CLOC} tool.}.

\begin{table}[!htbp]
    \caption{Lines of code for various PostgreSQL PL implementations}
        \label{table:LOC}
        \begin{tabular}{l | l}
                \toprule
                \rowcolor{gray!25} \textbf{PL implementation} & \textbf{Lines of code} \\ \midrule
                pl/java                                       & 54984                  \\
                pl/v8                                         & 29526                  \\
                pl/pgsql                                      & 13614                  \\
                pl/lua                                        & 13008                  \\
                pl/python                                     & 4535                   \\
                pl/r                                          & 4413                   \\
                pl/dotnet                                     & 4040                   \\
                pl/perl                                       & 2741                   \\ \bottomrule
        \end{tabular}
\end{table}

Table \ref{table:pldotnet_support_types} lists the PostgreSQL data
types support by pl/dotnet, which use exactly the same type mapping
as Npgsql. (The type names are sometimes different in F\#.)

\begin{table}[!htbp]
        \caption{pl/dotnet support types.}
        \label{table:pldotnet_support_types}
        \begin{tabular}{l | l}
                \toprule
                \rowcolor{gray!25} \textbf{PostgreSQL} & \textbf{pl/dotnet}                      \\ \midrule
                BIT                                    & \texttt{BitArray}                       \\
                BOOL                                   & \texttt{bool}                           \\
                BOX                                    & \texttt{NpgsqlBox}                      \\
                BPCHAR                                 & \texttt{string}                         \\
                BYTEA                                  & \texttt{byte[]}                         \\
                CIDR                                   & \texttt{IPAddress Address, int Netmask} \\
                CIRCLE                                 & \texttt{NpgsqlCircle}                   \\
                DATE                                   & \texttt{DateOnly}                       \\
                FLOAT4                                 & \texttt{float}                          \\
                FLOAT8                                 & \texttt{double}                         \\
                INET                                   & \texttt{IPAddress Address, int Netmask} \\
                INT2                                   & \texttt{short}                          \\
                INT4                                   & \texttt{int}                            \\
                INT8                                   & \texttt{long}                           \\
                INTERVAL                               & \texttt{NpgsqlInterval}                 \\
                JSON                                   & \texttt{string}                         \\
                LINE                                   & \texttt{NpgsqlLine}                     \\
                LSEG                                   & \texttt{NpgsqlLSeg}                     \\
                MACADDR                                & \texttt{PhysicalAddress}                \\
                MACADDR8                               & \texttt{PhysicalAddress}                \\
                MONEY                                  & \texttt{decimal}                        \\
                PATH                                   & \texttt{NpgsqlPath}                     \\
                POINT                                  & \texttt{NpgsqlPoint}                    \\
                POLYGON                                & \texttt{NpgsqlPolygon}                  \\
                TEXT                                   & \texttt{string}                         \\
                TIME                                   & \texttt{TimeOnly}                       \\
                TIMESTAMP                              & \texttt{DateTime}                       \\
                TIMESTAMPTZ                            & \texttt{DateTime}                       \\
                TIMETZ                                 & \texttt{DateTimeOffset}                 \\
                UUID                                   & \texttt{Guid}                           \\
                VARBIT                                 & \texttt{BitArray}                       \\
                VARCHAR                                & \texttt{string}                         \\
                XML                                    & \texttt{string}                         \\ \midrule
                \multicolumn{2}{l}{Ranges}                                                       \\ \midrule
                DATERANGE                              & \texttt{NpgsqlRange<DateOnly>}          \\
                INT4RANGE                              & \texttt{NpgsqlRange<int>}               \\
                INT8RANGE                              & \texttt{NpgsqlRange<long>}              \\
                TSRANGE                                & \texttt{NpgsqlRange<DateTime>}          \\
                TSTZRANGE                              & \texttt{NpgsqlRange<DateTime>}          \\ \bottomrule
        \end{tabular}
\end{table}

pl/dotnet supports all of the range data types in PostgreSQL.
We skipped multirange support for the time being and intend
to add it in the future.

\subsubsection{Arrays and Nulls}

All supported data types also support arrays of that type, be they
single-dimensional or multi-dimensional. We currently do that via
the Npgsql convention of mapping them to \texttt{Array<Type>}, but
that type mapping is cumbersome and expensive compared to the
somewhat different \texttt{Type[]} representation.

The source of this problem is an unfortunate design choice in
PostgreSQL, which tracks types according to their \texttt{OID}.
Each datatype has a corresponding array datatype, with its own OID,
but this OID does not encode the dimensionality of the array; thus,
all arrays in PostgreSQL may be of arbitrary dimension\footnote{Up
to the hard limit (\textquote{\texttt{MAXDIM}}) of \href{https://github.com/postgres/postgres/blob/master/src/include/utils/array.h\#L75}{6}.},
regardless of which dimension they were declared with. You can see
this reflected in the PostgreSQL manual:

\captionsetup[figure]{labelformat=empty}

\begin{figure}[h]
\begin{quote}
The syntax for CREATE TABLE allows the exact size of arrays to be
specified, for example:

\begin{minted}[frame=single,style=borland]{sql}
CREATE TABLE tictactoe (
    squares integer[3][3]
);
\end{minted}

However, the current implementation ignores any supplied array size
limits, i.e., the behavior is the same as for arrays of unspecified
length.

The current implementation does not enforce the declared number of
dimensions either. Arrays of a particular element type are all
considered to be of the same type, regardless of size or number of
dimensions. So, declaring the array size or number of dimensions
in CREATE TABLE is simply documentation; it does not affect run-time
behavior.
\end{quote}
\caption{\href{https://www.postgresql.org/docs/15/arrays.html}{Postgresql Manual, Ch. 8.15, Arrays}}
\end{figure}

Because Npgsql cannot know the dimensionality of the arrays it will
receive in a client context, it must use an object representation
which can handle any dimensionality; this is cumbersome in development
and slow in execution. However, since we are operating in a stored
procedure context instead of a client context, we have another
option available to us.

PostgreSQL does not directly tell us the dimensionality of the
array, merely giving us the array OID instead, but we also have
access to the raw SQL function definition in the database via the
\texttt{pg\_get\_functiondef()} function. By re-parsing
the function definition, we can see what dimensionality the user
specified when they created the function. Armed with this, in cases
where the input array does not match the specified dimensionality,
we can return an error, and otherwise we can pass an
appropriately-dimensioned array to the user function. In this way,
we can use the fast, unboxed representation (\textquote{\texttt{int[][]}})
instead of the Npgsql-standard object representation
(\textquote{\texttt{Array<int>}}.)

This behavior would be more strict than the standard PostgreSQL
behavior, and it would not be fully compatible with Npgsql, so we
would probably require developers to explicitly choose it.  However,
it would be safer than the standard behavior, and it would be easier
to code for, and it would have much better performance.  We anticipate
implementing this behavior in a future release, and we are very
hopeful for its performance benefits.

All types in PostgreSQL are nullable by default, so our default
handling is to map parameters to the nullable type (\texttt{T?}) in \dotnet,
which is similar to a \texttt{Maybe} type in Haskell. For PostgreSQL
functions that are defined as \texttt{STRICT}, the function will not be
invoked with null values, so in that case we map the type to the
simpler \texttt{T} type. We hope to make this behavior configurable for
the developer in the future.

\subsection{Parameter Modes}

pl/dotnet currently supports only parameter input, not parameter
output. Thus, we consume both \texttt{IN} and \texttt{INOUT} parameters,
but it is not currently possible to output an \texttt{INOUT} parameter.
We silently skip \texttt{OUT} parameters. This handling matches
the current handling in pl/python.

\dotnet\ supports output parameters, and we anticipate fully
supporting value output for both \texttt{INOUT} and \texttt{OUT} parameters.

\subsection{Function, Procedure, DO, Trigger}

PostgreSQL has several ways that code can be invoked from a procedural
language:
\begin{enumerate}[itemsep=0pt]
    \item As a user function (\textquote{\texttt{CREATE FUNCTION}}), taking parameters and returning a value.
    \item As a procedure (\textquote{\texttt{CREATE PROCEDURE}}), taking arguments but not returning a value.
    \item As a \textquote{\texttt{DO}} block, creating a transient anonymous function in a procedural language.
    \item As a trigger (\textquote{\texttt{CREATE TRIGGER}}), which is a function called when certain database events happen.
\end{enumerate}

pl/dotnet currently supports user functions, procedures, and \texttt{DO} blocks.
Triggers are partially supported but unreleased, and we anticipate
fully supporting them soon.

\subsection{Using Both Code and Assemblies}

Traditional PostgreSQL procedural languages, such as pl/pgsql
and pl/python, support creating user functions by passing the
code as part of the declaration of the function.

Alternatively, PostgreSQL's pl/java, along with the \dotnet (CLR)
implementations in Microsoft's SQLServer and IBM's DB2, support
loading a function from a pre-compiled assembly (\textquote{\texttt{.dll}}
or \textquote{\texttt{jar}}) file.

pl/dotnet supports both modes.  First, here are examples of directly
entering the code in both C\# and F\#:

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single, fontsize=\footnotesize]{sql}
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER, b SMALLINT)
RETURNS INTEGER AS $$
  return a+b;
$$ LANGUAGE plcsharp STRICT;
\end{minted}
\end{listing}

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single, fontsize=\footnotesize]{sql}
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER, b SMALLINT)
RETURNS INTEGER AS $$
  a+b;
$$ LANGUAGE plfsharp STRICT;
\end{minted}
\end{listing}

Second, here is an example of loading the function from a DLL, which
shoud work for any \dotnet\ language.

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single, fontsize=\footnotesize]{sql}
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER)
RETURNS INTEGER AS 'Sample.dll:Namespace.Class!IntegerTest'
LANGUAGE plcsharp STRICT;
\end{minted}
\end{listing}

PostgreSQL does have support for declaring the library from which
to load a function, but only for natively-compiled (that is, C)
functions. For other Procedural Languages, the PostgreSQL parser
currently does not pass the file location to the language handler,
as this was not an anticipated use case. For newer language handlers
like pl/dotnet and pl/java, which also support loading code from
external libraries/archives/assemblies, this would be a nice feature
for PostgreSQL to provide, and we are interested in submitting this
change upstream to PostgreSQL.

\subsection{Platform support}

\subsubsection{Operating systems and CPU}

pl/dotnet is developed on Linux and has been fully tested on both
x86 and ARM CPUs, suggesting the absence of any obvious endianness
bugs.

Our build environment is container-based, allowing us a stable and
repeatable build environment. We build on Bullseye\footnote{Ride
like the wind, Bullseye!}, version 11 of the Debian Linux distribution.
We use the system dpkg versions of both \dotnet and PostgreSQL.\@We
build, install, and test a standard debian package (\textquote{dpkg}).

Both PostgreSQL and \dotnet\ work on both Windows and macOS, and we
would like for pl/dotnet to do the same; given that we have few
system dependencies in the code, and those are very standard, we
do not anticipate any significant problems in adding support for
those operating systems. However, given that most PostgreSQL usage
is on Linux, we decided that prioritizing Linux support and leaving
the other platforms until later made sense; our focus for now is
on growing the system's functionality, not expanding its range of
support.

We welcome code contributions to support pl/dotnet on other
Linux distributions and on other operating systems.

\subsubsection{Postgresql versions}

We support PostgreSQL versions 10, 11, 12, 13, 14, and 15.
Currently, all features are supported for all PostgreSQL
versions, and the only anticipated exception to that support
is multirange, which was added in PostgreSQL v14, and which
we intend to add support for soon.

\subsubsection{\dotnet\ versions}

We currently develop against \dotnet version 6. We are currently
adding \dotnet version 7 support, and it will not be difficult.
Support for older versions of \dotnet would also not be difficult,
but we currently have no need for it.

\subsection{Security}

Security in pl/dotnet is limited. We use separate Assembly Load Contexts\footnote{\url{https://learn.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-7.0}}
for each stored procedure, which provides some level of isolation
between them: they exist in separate namespaces and generally
do not have access to each other's code or data, or that of
the underlying system.

Thus, there is no straightforward way for stored procedures to
interfere with PostgreSQL, but it might be possible to do so with
not-straightforward paths. We could marginally improve the security
of the system by reducing the set of libraries available to
stored procedures, but even this would not be a guarantee.

Microsoft previously attempted to provide these guarantees in
dotnet with AppDomain\footnote{\url{https://learn.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable}}
but eventually gave up and (rightly) deprecated it. The number
of potential avenues of attack are simply too great to be able
to secure with certainty unless the platform is designed
from the ground up to provide such security, and almost no modern
language runtimes were engineered in that way.

This problem is faced by every stored procedure language, and unless
the language provides air-tight guarantees as to its security, then
we think that skepticism regarding such assurances is warranted.
Few languages in existence provide such guarantees, and we do not
think that any of the current stored procedure languages qualify;
only pl/tcl even makes such a claim, and while we respect their
design, we would still probably not fully trust it for security-critical
usage.

The fundamental problem is that stored procedures are executing
inside of the PostgreSQL server's memory space, and the operating
system and CPU provide no memory protection between the stored
procedures and the database. This is the fundamental tradeoff to
be made in order to get the increased performance which stored
procedures provide.

Even with these limitations, we think there is a security argument
to be made for this approach. In the normal use case, database
clients cannot easily interfere with PostgreSQL's internal operation,
but they have access, usually unrestricted, to modify or delete the
data

We here should think about why PostgreSQL's integrity is important.
It is unusual that an attacker wishes to use one application to subvert
the server in order to access to another database, because
most databases are not shared in the modern environment. Thus, the
only function which is served by PostgreSQL's integrity is to
enforce the security restrictions on the application's database.

In an environment where the client has unfettered read/write access
to the database, and that is the common case, the integrity of
PostgreSQL is not important, because an attacker who has subverted
the client already has full access.

It is generally easier to subvert the security of a client process,
for example in a public-facing web server, than it is to subvert
the security of the database or the stored procedures which it
holds. By trusting a limited set of code inside of the database,
it is possible to dramatically limit the trust one needs to extend
to the database client, which is generally larger, more exposed,
and more difficult to secure. Because the client no longer needs
unrestricted write access to the database, this change will usually
yield an improvement in overall security, often a dramatic one.

For this reason, we feel good about the security implications of
our design for many classes of users.

Stored procedure authors must be the final arbiters of their security
tradeoffs. They should, as always, take care that their code not
introduce means to be subverted by malicious input. This is easier
in a memory-safe environment like \dotnet.

Security-critical applications do exist, and we are interested in
serving them. If we do so, then it will be via a sidecar, a separated
operating system process context with full memory protection, using
message passing or shared memory to communicate to the database
server on the same host operating system. Unless and until such a
system is built, we recommend thoughtful evaluation of whether the
security of the current system is appropriate to your application.
For most current applications, we think that it can be.

\subsection{Codebase Quality}
%Testing, Static Analysis, and Documentation
%TODO Update title

In order to improve our codebase quality, we have built unit tests for all supported datatypes, their arrays, and null handling in C\#.
We currently test a limited but representative
range of datatypes in F\# and anticipate extending that test support
to full coverage in the future.

We use three static analysis tools:
\begin{enumerate}[itemsep=0pt]
        \item Cpplint\footnote{\url{ https://github.com/cpplint/cpplint}} is a static code checker for C and C++.
        \item StyleCop\footnote{\url{ https://github.com/DotNetAnalyzers/StyleCopAnalyzers}} is a static code analysis tool. Formerly a standalone tool, it was refactored to become a series of Roslyn plugins.
        \item SonarLint\footnote{\url{ https://rules.sonarsource.com/csharp}} is a code quality and security static analysis tool with almost 5000 rules.
\end{enumerate}

C and C\# code in pl/dotnet is clean under the cpplint, StyleCop, and
SonarLint checks.

Source code in pl/dotnet, both C and C\#, is documented using Doxygen,
and the generated documents are reasonably complete in explaining
the system.

\subsection{Future Features}

PostgreSQL supports stored procedures themselves making SQL calls back
into the database via the Server Programming Interface (SPI). We
have an initial implementation of SPI, but it is not very safe at
the moment, so we chose not to include it in the first version.

Our intention is to map SPI to a fully-conformant Npgsql connection
object, which should again maximize compatibility between code
run in a client context and code run in a stored procedure context.

We do not currently support dynamic database types, such as enums,
composites, domain types, and other user-defined types. Npgsql
does support them, and we intend to add them in the future, but
their handling is somewhat delicate, so we chose to ship the first
version without them.  We also do not support the Numeric type.

PostgreSQL supports set-returning functions (SRFs), which lazily
return a potentially-infinite set of values. This database
functionality maps nicely to the \texttt{IEnumerable<T>} interface
in C\# and \texttt{seq<'T>} in F\# (the ML idiom which in F\# is
just an alias for \texttt{IEnumerable<T>}.)

We have a prototype implementation of SRFs which supports returning
both finite and infinite sets and includes careful garbage collection
of the iterator. (Especially for inifinite sets, the database must
tell you when it is done consuming values, and you then must destroy
the iterator in order not to leak memory.) We anticipate fully
supporting SRFs soon.

We plan to give developers more control over code isolation by
placing each DLL in its own AssemblyLoadContext.  Thus, code from
the same DLL can share state, while functions are otherwise isolated
from each other.  This will let users control data sharing between
their functions by controlling which DLLs hold their functions.

Our automated tests cover not only C\# and F\#, but also numerous
other stored procedure languages.  We hope to share these in more
polished form for use by other PL teams and to facilitate cooperation
across the PostgreSQL PL community.

\section{\dotnet\ implementation}

\subsection{Architecture}

Any stored procedure language in PostgreSQL is going to have some
mix of C code and language-specific code, and there are choices to
be made in where and how you express functionality. We liked the
increased safety of working in C\#, and we valued the richer set of
programming tools, so our decision was to keep the C code to a
minimum and use C\# wherever possible handle the transfer of data
into and out of user functions.

This stands in contrast to some other PL implementations, and
pl/python is an interesting example.  pl/python is implemented
entirely in C, and we have learned much from it.  The Python C API
is very good, but it is still C.  Having been built in C, pl/python
must pay careful attention to manual memory management, and building
objects is tedious.  Despite our having a much wider range of native
data type support than pl/python, we only have 25\% as many lines
of C code, 1123 versus 4533.  (Adding SPI support, our only major
missing feature, should add only a few hundred lines of code.) Since
C\# is still compiled via the \dotnet\ JIT, and the CLR must be
used anyway we do not sacrifice much performance this way.  Further,
with our code generation strategy, we actually have a superior
execution path to C engines such as pl/python's, and our performance
is superior, despite building most of our logic in C\#.  For these
reasons, we think keeping most handling in C\# is a good design
decision for us.

Every piece of data in PostgreSQL is expressed in a datum, and each
datum has an Object IDentifier (\textquote{\texttt{OID}}) for its
type. (This OID is not in the datum at runtime; it is in the type
definition for the function at compile time.) For each data type,
pl/dotnet has a pair of small C function whose purpose is to get
the values out of the datum to \dotnet\ (called \texttt{InputValue()})
and then back from \dotnet\ into the datum (called \texttt{OutputValue()}.)
All of the remaining handling is then done in C\#. This also has
the nice effect of keeping both C code and unsafe C\# code to a
minimum; they are strictly limited to getting data into and back
out of \dotnet.

When a function is created, pl/dotnet creates two assemblies: the
UserHandler, and the UserFunction.  The UserFunction is a minimal
wrapper around the user's code, or in cases where the user has
loaded the function from a pre-compiled assembly, then it is just
that assembly.  The UserHandler is responsible for marshalling
values out of the database, calling the UserFunction, and then
returning the result values back into the database.

Among PostgreSQL PL implementations, we are unique in generating
and compiling custom code for each user function.  This gives us
two advantages.  First, we specialize the possible universe of type
conversions to the specific ones we need at the time of function
creation, not at runtime.  Second, this minimal codepath is then
compiled.  Both of these factors contribute to our unusually fast
execution time.

Another nice feature of this architecture is that, because the
UserHandler is so cleanly separated from the UserFunction, support
for pre-compiled DLLs was straightforward. Further, it makes F\#
support easy, because we can reuse the C\# implementation of the
UserHandler and need only compile the UserFunction in F\#, which
is then easily callable from C\#.\footnote{The details of this
handling are still evolving for F\#, because of the differences
between F\# Compiler Services and Roslyn.}

Adding other \dotnet languages would be similarly easy, and if someone
would like to pay us a sufficient quantity of money, then we would
be willing to add Visual Basic support, but otherwise such support
is not currently planned.

When a function is called from PostgreSQL, C builds an array of
datums\footnote{We here refer to the plural of a PostgreSQL type
\textquote{Datum} as \textquote{Datums} in order to differentiate
them technically from the more generic \textquote{Data}.} with the
function arguments and passes them to C\#. C\# knows the type of
each argument from when the function was created, and it calls the
corresponding handlers for each type to convert it from a PostgreSQL
datum to a \dotnet value.  The C\# handler handles NULLs and arrays,
and this code is nicely generic.

After those values have been passed to the user function, the return
value follows the reverse path through the type handler to create
a PostgreSQL result datum, which is then returned to the database.

\subsection{Compilation and caching}

Both C\# and F\# make use of a template file which is then customized.
Users can optionally inspect the generated code.

pl/dotnet uses the the \dotnet\ Compiler Platform SDK, aka Roslyn\footnote{\url{https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/}}\footnote{\url{https://github.com/dotnet/roslyn}},
which is a set of compiler tools to compile C\# to an in-memory
assembly. Roslyn exposes the entire compiler pipeline to the
application, providing us various features when compiling
user functions, including:

\begin{itemize}[itemsep=0pt]
    \item extensive code checking
    \item informative error messages, including correct line numbers
    \item ability to rewrite the code in the AST if needed
    \item code inspection, including metadata
    \item fine-grined control over library availability
\end{itemize}

We use F\# Compiler Services (\textquote{FCS})\footnote{\url{https://fsharp.github.io/fsharp-compiler-docs/fcs/}}
in a similar way to dynamically compile F\# user functions into an
assembly. For historical reasons, the facilities offered by FCS
are not identical to Roslyn, but they are generally comparable.

The generated code is then compiled into in-memory assemblies. If
a pre-compiled assembly/DLL has been used, then that is loaded
alongside the generated UserHandler. For F\#, we support doing this
with both dynamic assemblies and normal assemblies. These assemblies
are loaded into an Assembly Load Context, which provides limited
isolation of one function from another and also from the core system.

The resulting assembly context is then cached for reuse on subsequent
calls. If the function has been dropped from the cache, either by
a cache replacement or by a database restart, then we will transparently
re-compile and the function the next time that it is called, again
caching the result.

\subsection{Strings}

pl/dotnet currently assumes that all PostgreSQL strings are encoded
in utf8, which is a superset of ASCII.  PostgreSQL supports other
character encodings, and we could extend our support for them, but
utf8 is the de facto standard today, so alternative encodings are
mostly of historical interest, making this functionality not urgent.

\dotnet\ spans let you create an object from only a pointer and a
length, leaving the contents where they lie rather than requiring
that they be copied.\footnote{\url{https://learn.microsoft.com/en-us/dotnet/standard/memory-and-spans/}}
Strings in pl/dotnet are handled via a \texttt{ReadOnlySpan}, which is
inexpensive and generally a nice interface.

Given its history as a Windows platform, \dotnet\ has a long history
of using utf16 as its default string encoding.  Mono, the
\dotnet\-compatible framework which was long the default on Linux,
mostly used utf8, and modern \dotnet\ on Linux does as well.  The
details of string encoding on different platforms and in different
circumstances in \dotnet\ are complicated and evolving, and we are
not confident that we understand \dotnet\'s internal behavior fully;
it remains an active topic of investigation for us.

We did implement careful utf8/utf16 conversion for all strings,
only to discover that it was unnecessary on Linux.  We have left
it in place for now, in anticipation of adding Windows support in
the future, where it will be needed.

\subsection{Applying PL/DOTNET with C\#}

We present a sample function to show the different parts of
the system working together.  We use Int16 and Int32 as the simplest
examples possible, letting us concentrate on the control flow
rather than the complexity of the type conversion.  Some of the
minor details have been simplified for presentation.

First is the SQL definition of the function; this is how the user
will create the function in PostgreSQL.

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single, fontsize=\footnotesize]{sql}
CREATE OR REPLACE FUNCTION IntegerTest(a INTEGER, b SMALLINT)
RETURNS INTEGER AS $$
    return a+b; // this is the user code
$$ LANGUAGE plcsharp STRICT;
\end{minted}
\caption{How to define a function}
\end{listing}

Here is a UML sequence diagram explaining the relative calls
between PostgreSQL, the C portion of pl/dotnet, the C\# portion
of pl/dotnet, and the user-supplied function.

\begin{figure*}
        \includegraphics[width=0.9\textwidth]{img/pldotnet-sequence-diagram.png}
        \caption{Figure \thefigure: pl/csharp Sequence Diagram}
\end{figure*}

Here is the generated C\# code.  Datum, which is handled as a
\texttt{void*} in C, is handled as an \texttt{IntPtr} in C\#.

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single,fontsize=\footnotesize]{csharp}
namespace PlDotNET.UserSpace {
 public static class UserFunction {
   public static int? integertest(int a, short b) {
#line 1
     return a + b; // this is the user code
   }
 }
 public static class UserHandler {
  public static IntHandler IntHandlerObj = new IntHandler();
  public static ShortHandler ShortHandlerObj = new ShortHandler();
  public static unsafe void CallUserFunction(List<IntPtr> arguments, IntPtr output, bool[] isnull) {
   var argument_0 = IntHandlerObj.InputValue(arguments[0]);
   var argument_1 = ShortHandlerObj.InputValue(arguments[1]);
   var result = PlDotNET.UserSpace.UserFunction.integertest( (int)argument_0, (short)argument_1);
   var resultDatum = IntHandlerObj.OutputNullableValue(result);
   OutputResult.SetDatumResult(resultDatum, result == null, output);
  }
 }
}
\end{minted}
\caption{Generated C\# code}
\end{listing}

%// As the SQL function named integertest is `STRICT` or `RETURNS NULL ON NULL INPUT`,
%// `PL.NET` doesn't check whether any argument datum is null.
%// You can also set true for the `Engine.AlwaysNullable` variable
%// to always check whether the datum is null.
%// BEGIN create arguments for integertest
%arg_0 and arg_1
%// END create arguments for integertest

Here is the generic conversion code, which handles NULLs and wraps the
type-specific conversion code:

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single,fontsize=\footnotesize]{csharp}
public abstract class StructTypeHandler<T> : BaseTypeHandler<T> where T : struct {
 public T? InputNullableValue(IntPtr datum, bool isnull) {
  return isnull ? null : this.InputValue(datum);
 }
 public IntPtr OutputNullableValue(T? value) {
  return value == null ? IntHandler.pldotnet_CreateDatumInt32(0) : this.OutputValue((T)value);
 }
}
\end{minted}
\caption{Generic conversion code}
\end{listing}
%// dotnet_src/TypeHandlers/GenericHandler.cs
%// In case of `null`, we set `isnull=True` and return a `0`, the PostgreSQL convention./

Here is the relevant integer-specific conversion code.

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single,fontsize=\footnotesize]{csharp}
public class IntHandler : StructTypeHandler<int> {
 [DllImport("@PKG_LIBDIR/pldotnet.so")]
 public static extern int pldotnet_GetInt32(IntPtr datum);
 [DllImport("@PKG_LIBDIR/pldotnet.so")]
 public static extern IntPtr pldotnet_CreateDatumInt32(int value);

 public override int InputValue(IntPtr datum) {
  return pldotnet_GetInt32(datum);
 }
 public override IntPtr OutputValue(int value) {
  return pldotnet_CreateDatumInt32(value);
 }
}
\end{minted}
\caption{Main integer-specific conversion code}
\end{listing}
%// dotnet_src/TypeHandlers/IntegerHandler.cs

Here is the C code, which uses the relevant PostgreSQL macros (etc)
for Datum conversion.  These would have been tedious and error-prone
to implement as unsafe C\# code, in addition to being fragile to
upstream changes in PostgreSQL, so instead we built C wrappers for
them.

\begin{listing}[H]
\begin{minted}[breaklines, breakafter=d, frame=single,fontsize=\footnotesize]{csharp}
int32_t pldotnet_GetInt32(void *datum) {
 return DatumGetInt32((Datum)datum);;
}
Datum pldotnet_CreateDatumInt32(int32_t value) {
  return Int32GetDatum(value);
}
\end{minted}
\caption{C code with PostgreSQL macros}
\end{listing}
%// src/pldotnet_conversions.c

As you can see, the minimum of processing is done in C, and everything
else is handled in C\#.  For this reason, each datatype has a pair
of C handlers (input and output) in
\textquote{\texttt{src/pldotnet\_conversions.c}} and a corresponding
pair of C\# wrappers in \textquote{\texttt{dotnet\_src/TypeHandlers/}}.


% \section{Evaluation Description}
% We describe our questions to be addressed with the experiments
% How we will answer each question

% A subsection explaining the indicators that we used. For instance, execution time.

% a subsection explaining the test set used and where we can find them.

\section{Results and Analyses}

We have built automated testing for over a hundred features across
a range of other PostgreSQL procedural languages:

\begin{table}[!htbp]
       \caption{Comparison between PSQL Procedural Languages.}
       \begin{tabular}{l | c }
               \toprule
               \rowcolor{gray!25} \textbf{language} & \textbf{\# tests} \\ \midrule
               java                                 & 115               \\
               lua                                  & 102               \\
               perl                                 & 110               \\
               pgsql                                & 109               \\
               python                               & 118               \\
               r                                    & 105               \\
               tcl                                  & 108               \\
               v8javascript                         & 109               \\ \bottomrule
       \end{tabular}
\end{table}

We hope to assemble these tests into a unified suite which can be
used by the entire PostgreSQL PL community. We hope that this can
help us all improve performance, improve cooperation across the PL
space, and help us work together to drive improvement in PostgreSQL
to support the PL implementations.

\subsection{Performance}

We used these tests for benchmarking pl/dotnet. We will now present
these results.

It is important first to say that these benchmarks were not designed
to fairly (or unfairly) evaluate the performance of other languages.
Rather, they were intended to help us explore other languages'
handling of PostgreSQL datatypes, understand pl/dotnet's performance,
and find our own problems. They cover a wide range of stored
procedure types and functionality, but they are not intended (and
probablly cannot be) representative of the actual performance
experienced by users, which will of course depend on the particular
features which they use. We merely built the tests we needed for
comparison, ran them, and benchmarked pl/dotnet's performance against
them.

Under these tests, pl/dotnet's performance compared to the other
procedural languages was good. We think it was especially good
considering that we have barely started optimizing; significant
improvements remain.

To compute total performance, we equally weighted each test and
compared pl/dotnet against the other PL in question. First, a
summary:

% TODO: C# and F#?

\begin{table}[!htbp]
       \caption{Comparison of the execution time in relation to pl/dotnet.}
       \begin{tabular}{l | c }
               \toprule
               \rowcolor{gray!25} \textbf{Programming Language} & \textbf{Execution time} \\ \midrule
                pl/pgsql             &   93.80\%    \\
                pl/fsharp            &  101.56\%    \\
                pl/perl              &  109.13\%    \\
                pl/python            &  110.95\%    \\
                pl/tcl               &  130.23\%    \\
                pl/lua               &  133.70\%    \\
                pl/java              &  138.47\%    \\
                pl/v8                &  185.62\%    \\
                pl/r                 &  188.15\%    \\ \bottomrule
       \end{tabular}
\end{table}

\autoref{fig:comparison} shows the graphs of the relative performance
of each language.  \autoref{fig:heatmap} is the more detailed graph
showing relative performance for each test in a heatmap.

\begin{figure*}[!htbp]
        \centering
        \boxed{
                \includegraphics[scale=0.25]{img/pldotnet-performance-comparison.png}
        }
        \caption{\centering Figure \thefigure: Performance graphs for pl/csharp compared to other PostgreSQL Procedural Languages}
        \label{fig:comparison}
\end{figure*}

\begin{figure*}[!htbp]
        \centering
        \boxed{
            \includegraphics[width=6in]{img/heatmap.png}
        }
        \caption{\centering Figure \thefigure: Performance heatmap for all PostgreSQL Procedural Languages plus pl/csharp and pl/fsharp}
        \label{fig:heatmap}
\end{figure*}

As you can see, pl/dotnet is faster than every other PL, with the
exception of pl/pgsql. pl/pgsql has always been the fastest language
in PostgreSQL, because its native datatype representation is the
PostgreSQL representation, so it does not need to perform any data
conversions.

Our results had been advantaged by a small number of tests with
recursive functions, which \dotnet\ handles well and which pl/pgsql
apparently does not.  We think recursive functions are important,
especially for functional programming.  However, given that they
heavily skewed the results, we have excluded them from this dataset
and from the resulting performance figures.

We are pleased that our performance against pl/pgsql is so relatively
strong, even with our having excluded the recursive tests.  We will
be trying to reach parity or surpass it.

Across all language comparisons, there are a small number of tests
where pl/dotnet performance is relatively bad, and these are the
array tests. This is caused by the Npgsql object representation of
variably-dimensioned arrays.

The fact that PostgreSQL enforces neither the specified array size
nor the specified array dimension is unfortunate for languages
like C\# which feature very fast array support but which, in the
absence of fixed dimensionality, must fall back on cubersome object
representations even for the common case of a single-dimensional
array.

As mentioned previously, we have thoughts for how we can improve
array performance in pl/dotnet, perhaps significantly. Further,
PostgreSQL could (and in our opinion should) be updated to enforce
the functional and schema specifications of array dimension. We
recognize that this would be a large change, but it would improve
type safety and eliminate many unnecessary SQL bugs.

For the time being, our goal remains 100\% Npgsql compatibility, and
we are willing to suffer the moderate performance impact of its
array handling in order to preserve the greater goal of code mobility.
Any performance enhancements along these lines in the future will
be optional, with the default behavior remaining Npgsql-compatibile.

\subsection{Type support}

We consider 46 PostgreSQL types to be non-system types, intended
for users.  Of these, we support 38 for them, and we have a
clear roadmap to support all 45.

Numerous of the PL implementations for scripting languages, such
as pl/python and pl/tcl, achieve type support by passing the
PostgreSQL string representation to their functions for most or all
data types. This nominally achieves full type support, but at the
cost of pushing ambiguity and processing work onto the developer,
as well as significant run-time overhead. We do not consider this
to be \textquote{native} support.

pl/dotnet and pl/java map PostgreSQL values into their platform's
corresonding native type. Here, we were greatly aided by the
existence of Npgsql, which already has extensive mapping of the
PostgreSQL type system to the \dotnet type system. Leveraging their
work, we are able to have the greatest range of native type support
of any external procedural language in PostgreSQL.

We still have four gaps in our type coverage: the Numeric type;
composite types, also known as record types; enumerated types
(\textquote{ENUM}); and multirange support for all five range types.
(Multirange will be a single, generic implementation.)

We indend to add all of these, which would make us the first external
procedural language with 100\% native support of all PostgreSQL
user types.

% TODO: build a type support table showing the PSQL PL's, along with DB2 and SqlServer

\section{Conclusion}

% TODO: do we think?

We believe pl/dotnet is an interesting contribution to the PostgreSQL
and \dotnet ecosystems. We hope that PostgreSQL users will find it
useful.  We welcome feedback on the project, and we look forward
to improving it.

We thank the authors of \dotnet, PostgreSQL, and Npgsql for their work,
without which this project would not be possible.

\balance
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak
%\onecolumn
%\appendix

\tableofcontents

\end{document}
